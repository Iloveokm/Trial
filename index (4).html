<!DOCTYPE html>
<html lang="hi" class="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Application Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        /* Basic Styles */
        body { font-family: 'Inter', sans-serif; }
        .scrollbar-thin::-webkit-scrollbar { width: 5px; }
        .scrollbar-thin::-webkit-scrollbar-track { background: #f1f1f1; }
        .scrollbar-thin::-webkit-scrollbar-thumb { background: #888; border-radius: 5px; }
        .scrollbar-thin::-webkit-scrollbar-thumb:hover { background: #555; }

        /* Light Theme */
        :root {
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f1f5f9;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --border-color: #e2e8f0;
            --message-sent-bg: #dcf8c6;
            --message-received-bg: #ffffff;
            --icon-color: #64748b;
        }

        /* Dark Theme */
        html.dark {
            --bg-primary: #0b1426;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --border-color: #334155;
            --message-sent-bg: #056162;
            --message-received-bg: #334155;
            --icon-color: #94a3b8;
        }

        /* Apply Theme Variables */
        body { background-color: var(--bg-primary); color: var(--text-primary); }
        .bg-theme-secondary { background-color: var(--bg-secondary); }
        .bg-theme-tertiary { background-color: var(--bg-tertiary); }
        .text-theme-primary { color: var(--text-primary); }
        .text-theme-secondary { color: var(--text-secondary); }
        .border-theme { border-color: var(--border-color); }
        .message-bubble-sent { background-color: var(--message-sent-bg); }
        .message-bubble-received { background-color: var(--message-received-bg); }
        .icon-theme { color: var(--icon-color); }
        .hover\:bg-theme-tertiary:hover { background-color: var(--bg-tertiary); }
        .message-content img, .message-content video { max-width: 300px; border-radius: 0.5rem; }
        .toggle-checkbox:checked { right: 0; border-color: #48bb78; }
        .toggle-checkbox:checked + .toggle-label { background-color: #48bb78; }
        .sent-icon { color: #888; }
        .delivered-icon { color: #51a8ff; }
        .seen-icon { color: #4ade80; }

        /* Fullscreen Image Modal Styles */
        .fullscreen-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        .fullscreen-modal img {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
        }
        .fullscreen-modal .close-btn {
            position: absolute;
            top: 20px;
            right: 30px;
            color: white;
            font-size: 40px;
            cursor: pointer;
            z-index: 101;
        }

        /* Call Modal Styles */
        .call-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: white;
        }
        .call-modal .video-container {
            position: relative;
            width: 80%;
            height: 70%;
            background-color: black;
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .call-modal video {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Adjusted to contain for better fitting on smaller screens */
            background-color: black;
        }
        .call-modal .local-video {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 90px;
            border-radius: 8px;
            background-color: #333;
            border: 2px solid white;
            z-index: 10;
        }
        .call-modal .call-controls {
            display: flex;
            gap: 20px;
            margin-top: 30px;
        }
        .call-modal .call-controls button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 15px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s ease;
        }
        .call-modal .call-controls button.hangup {
            background-color: #f44336;
        }
        .call-modal .call-controls button:hover {
            opacity: 0.8;
        }
        .call-modal .call-status {
            margin-bottom: 20px;
            font-size: 20px;
            font-weight: bold;
        }
        .call-incoming-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #4CAF50;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 1001;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .call-incoming-notification button {
            background-color: white;
            color: #4CAF50;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        .call-incoming-notification button.reject {
            color: #f44336;
        }
    </style>
</head>
<body class="bg-theme-primary">
    <div id="loading-spinner" class="fixed inset-0 bg-white bg-opacity-75 flex items-center justify-center z-50 hidden">
        <i class="fas fa-spinner fa-spin text-4xl text-blue-500"></i>
    </div>

    <div id="maintenance-screen" class="hidden fixed inset-0 bg-theme-primary flex flex-col items-center justify-center text-center p-4 z-40">
        <i class="fas fa-tools text-6xl text-theme-secondary mb-4"></i>
        <h1 class="text-3xl font-bold text-theme-primary">Site Under Maintenance</h1>
        <p class="text-theme-secondary mt-2">We are currently performing maintenance. We will be back shortly. Thank you for your patience.</p>
    </div>

    <div id="auth-screen" class="min-h-screen flex items-center justify-center">
        <div class="max-w-md w-full bg-theme-secondary p-8 rounded-lg shadow-lg">
            <h2 id="auth-title" class="text-2xl font-bold text-center text-theme-primary mb-6">Login</h2>
            <form id="auth-form">
                <input id="email" type="email" placeholder="Email" class="w-full px-4 py-2 mb-4 border border-theme bg-theme-secondary rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" required>
                <input id="password" type="password" placeholder="Password" class="w-full px-4 py-2 mb-4 border border-theme bg-theme-secondary rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" required>
                <button type="submit" id="auth-button" class="w-full bg-blue-500 text-white py-2 rounded-lg hover:bg-blue-600 transition duration-200">Login</button>
            </form>
            <p id="auth-error" class="text-center text-sm text-red-500 mt-2 hidden"></p>
            <p class="text-center text-sm text-theme-secondary mt-4">
                <span id="auth-toggle-text">Don't have an account?</span>
                <a href="#" id="auth-toggle-link" class="text-blue-500 hover:underline">Sign Up</a>
            </p>
        </div>
    </div>
    <div id="main-app" class="hidden h-screen w-full md:flex">
        <div id="chat-list-container" class="w-full md:w-1/3 lg:w-1/4 bg-theme-secondary border-r border-theme flex flex-col">
            <div class="p-4 border-b border-theme flex justify-between items-center">
                <h2 class="text-xl font-bold">Chats</h2>
                <div id="user-profile" class="relative">
                    <img id="user-avatar" src="https://placehold.co/40x40/EFEFEF/AAAAAA&text=U" class="w-10 h-10 rounded-full cursor-pointer">
                    <div id="user-menu" class="hidden absolute right-0 mt-2 w-48 bg-theme-secondary rounded-md shadow-lg py-1 z-20 border border-theme">
                        <a href="#" id="theme-toggle-button" class="block px-4 py-2 text-sm text-theme-primary hover:bg-theme-tertiary"><i class="fas fa-sun mr-2"></i><span>Switch to Dark Mode</span></a>
                        <a href="#" id="edit-profile-button" class="block px-4 py-2 text-sm text-theme-primary hover:bg-theme-tertiary"><i class="fas fa-user-edit mr-2"></i>Edit Profile</a>
                        <a href="#" id="admin-panel-button" class="hidden block px-4 py-2 text-sm text-theme-primary hover:bg-theme-tertiary"><i class="fas fa-user-shield mr-2"></i>Admin Panel</a>
                        <a href="#" id="logout-button" class="block px-4 py-2 text-sm text-theme-primary hover:bg-theme-tertiary"><i class="fas fa-sign-out-alt mr-2"></i>Logout</a>
                    </div>
                </div>
            </div>

            <div class="p-2 border-b border-theme">
                 <button id="chat-with-admin-btn" class="w-full bg-green-500 text-white py-2 px-4 rounded-lg hover:bg-green-600 transition duration-200 flex items-center justify-center">
                    <i class="fas fa-headset mr-2"></i> Chat with Support
                </button>
            </div>

            <div id="user-list" class="flex-1 overflow-y-auto scrollbar-thin">
            </div>
        </div>

        <div id="chat-window-wrapper" class="flex-1 flex-col bg-theme-primary hidden md:flex">
            <div id="welcome-screen" class="flex flex-col items-center justify-center h-full text-center">
                <i class="fas fa-comments text-6xl text-gray-400"></i>
                <h2 class="mt-4 text-2xl font-semibold text-theme-primary">Welcome to Chat App</h2>
                <p class="text-theme-secondary">Select a chat to start messaging</p>
            </div>

            <div id="chat-window" class="hidden flex-1 flex flex-col h-full">
                <div class="flex items-center justify-between p-3 border-b border-theme bg-theme-secondary">
                    <div class="flex items-center">
                        <button id="back-to-chats-btn" class="md:hidden mr-4 p-2 text-theme-secondary hover:text-theme-primary"><i class="fas fa-arrow-left text-xl"></i></button>
                        <img id="chat-header-avatar" src="https://placehold.co/48x48" class="w-12 h-12 rounded-full mr-4 cursor-pointer">
                        <div>
                            <h3 id="chat-header-name" class="font-semibold text-lg"></h3>
                            <p id="chat-header-status" class="text-sm text-green-500"></p>
                            <p id="typing-indicator" class="text-sm text-theme-secondary h-4"></p>
                        </div>
                    </div>
                    <div class="flex items-center space-x-2">
                        <button id="video-call-btn" class="p-2 text-blue-500 hover:text-blue-600 transition duration-200"><i class="fas fa-video text-xl"></i></button>
                        <button id="voice-call-btn" class="p-2 text-green-500 hover:text-green-600 transition duration-200"><i class="fas fa-phone text-xl"></i></button>
                        <button id="delete-chat-btn" class="bg-red-500 text-white py-2 px-4 rounded-lg text-sm hover:bg-red-600 transition duration-200"><i class="fas fa-trash-alt mr-2"></i>Delete Chat</button>
                    </div>
                </div>

                <div id="messages-container" class="flex-1 p-4 overflow-y-auto scrollbar-thin">
                </div>
                              <div class="bg-theme-secondary p-4 border-t border-theme">
                    <div id="reply-bar" class="hidden flex items-center justify-between p-2 mb-2 bg-theme-tertiary rounded-lg">
                        <div class="flex-1">
                            <p class="text-xs text-blue-500">Replying to:</p>
                            <p id="reply-text" class="text-sm font-semibold truncate"></p>
                        </div>
                        <button id="cancel-reply-btn" class="text-theme-secondary hover:text-red-500"><i class="fas fa-times"></i></button>
                    </div>

                    <div id="emoji-sticker-picker" class="hidden grid grid-cols-8 gap-2 p-2 bg-theme-tertiary rounded-lg mb-2">
                    </div>
                    <div class="flex items-center gap-3">
                        <button id="emoji-sticker-btn" class="p-2 icon-theme hover:text-blue-500 flex-shrink-0"><i class="fas fa-smile text-xl"></i></button>

                        <div class="flex-1 flex items-center border border-theme bg-theme-secondary rounded-full">
                            <input id="message-input" type="text" placeholder="Type a message..." class="flex-1 px-4 py-2 bg-transparent border-none rounded-full focus:outline-none focus:ring-0">
                            <button id="send-btn" class="bg-blue-500 text-white w-9 h-9 flex-shrink-0 mr-1 rounded-full hover:bg-blue-600 flex items-center justify-center"><i class="fas fa-paper-plane text-sm"></i></button>
                        </div>

                        <div class="relative flex-shrink-0">
                            <button id="more-options-btn" class="p-2 icon-theme hover:text-blue-500"><i class="fas fa-paperclip text-xl"></i></button>
                            <div id="more-options-menu" class="hidden absolute bottom-full right-0 mb-2 w-max bg-theme-secondary rounded-md shadow-lg py-1 z-20 border border-theme">
                                <button id="attach-file-btn" class="w-full flex items-center px-4 py-2 text-sm text-theme-primary hover:bg-theme-tertiary text-left"><i class="fas fa-file-image w-4 mr-3"></i>Attach File</button>
                                <button id="record-voice-btn" class="w-full flex items-center px-4 py-2 text-sm text-theme-primary hover:bg-theme-tertiary text-left"><i class="fas fa-microphone w-4 mr-3"></i>Record Voice</button>
                            </div>
                        </div>
                        <input type="file" id="file-input" class="hidden" accept="image/*,video/*">
                    </div>
                    <p id="recording-status" class="text-xs text-red-500 mt-1 hidden"><i class="fas fa-circle text-red-500 animate-pulse"></i> Recording...</p>
                </div>

            </div>
        </div>
    </div>

    <div id="edit-profile-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-30 p-4">
        <div class="bg-theme-secondary rounded-lg shadow-xl w-full max-w-sm">
            <div class="flex justify-between items-center p-4 border-b border-theme">
                <h3 class="text-xl font-bold">Edit Profile</h3>
                <button id="close-edit-profile-modal" class="text-gray-500 hover:text-gray-800 text-2xl">&times;</button>
            </div>
            <div class="p-4">
                <div class="flex flex-col items-center mb-4">
                    <img id="profile-avatar-preview" src="" class="w-24 h-24 rounded-full mb-2">
                    <button id="change-avatar-btn" class="text-blue-500 hover:underline text-sm">Change Photo</button>
                    <input type="file" id="avatar-input" class="hidden" accept="image/*">
                </div>
                <div class="mb-4">
                    <label class="block text-sm font-medium mb-1">Display Name</label>
                    <input type="text" id="display-name-input" class="w-full px-3 py-2 border border-theme bg-theme-secondary rounded-lg">
                </div>
                <button id="save-profile-btn" class="w-full bg-blue-500 text-white py-2 rounded-lg hover:bg-blue-600 transition">Save Changes</button>
            </div>
        </div>
    </div>

    <div id="fullscreen-image-modal" class="fullscreen-modal hidden" onclick="this.classList.add('hidden');">
        <span class="close-btn" onclick="event.stopPropagation(); this.parentNode.classList.add('hidden');">&times;</span>
        <img id="fullscreen-image" src="" alt="Full-screen image" onclick="event.stopPropagation();">
    </div>

    <div id="admin-panel" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-30 p-4">
        <div class="bg-theme-secondary rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] flex flex-col">
            <div class="flex justify-between items-center p-4 border-b border-theme">
                <h3 class="text-xl font-bold"><i class="fas fa-user-shield mr-2"></i>Admin Panel</h3>
                <button id="close-admin-panel" class="text-gray-500 hover:text-gray-800 text-2xl">&times;</button>
            </div>
            <div class="flex-1 flex overflow-hidden">
                <div class="w-1/4 border-r border-theme p-2">
                    <nav class="flex flex-col space-y-1">
                        <a href="#settings" class="admin-tab-link bg-theme-tertiary text-theme-primary font-semibold flex items-center px-3 py-2 rounded-md"><i class="fas fa-cog mr-3"></i>Settings</a>
                        <a href="#users" class="admin-tab-link text-theme-secondary hover:bg-theme-tertiary hover:text-theme-primary flex items-center px-3 py-2 rounded-md"><i class="fas fa-users mr-3"></i>Users</a>
                        <a href="#content" class="admin-tab-link text-theme-secondary hover:bg-theme-tertiary hover:text-theme-primary flex items-center px-3 py-2 rounded-md"><i class="fas fa-photo-video mr-3"></i>Content</a>
                    </nav>
                </div>
                 <div class="w-3/4 p-4 overflow-y-auto">
                    <div id="admin-tab-settings" class="admin-tab-content">
                        <h4 class="text-lg font-semibold mb-2">Site Settings</h4>
                        <div class="space-y-4 p-4 bg-theme-tertiary rounded-lg">
                            <div class="flex items-center justify-between">
                                <div>
                                    <label class="font-medium text-theme-primary">Maintenance Mode</label>
                                    <p class="text-sm text-theme-secondary">Put the site offline for non-admins.</p>
                                </div>
                                <div class="flex items-center">
                                    <span id="maintenance-status-text" class="text-sm font-semibold mr-3">OFF</span>
                                    <div class="relative inline-block w-12 align-middle select-none">
                                        <input type="checkbox" name="maintenance-toggle" id="maintenance-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                                        <label for="maintenance-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <h4 class="text-lg font-semibold mt-6 mb-2">Security</h4>
                        <div class="space-y-4 p-4 bg-theme-tertiary rounded-lg">
                             <div class="flex items-center justify-between">
                                <div>
                                    <label class="font-medium text-theme-primary">Allow New Registrations</label>
                                    <p class="text-sm text-theme-secondary">Allow new users to sign up.</p>
                                </div>
                                <div class="flex items-center">
                                    <span id="registration-status-text" class="text-sm font-semibold mr-3">ON</span>
                                    <div class="relative inline-block w-12 align-middle select-none">
                                        <input type="checkbox" name="registration-toggle" id="registration-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                                        <label for="registration-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                     <div id="admin-tab-users" class="admin-tab-content hidden">
                         <h4 class="text-lg font-semibold mb-2">Manage Users</h4>
                        <div id="admin-user-list" class="space-y-2">
                            </div>
                    </div>
                     <div id="admin-tab-content" class="admin-tab-content hidden">
                         <h4 class="text-lg font-semibold mb-2">Stickers & Emojis</h4>
                         <div class="p-4 bg-theme-tertiary rounded-lg">
                            <h5 class="font-semibold mb-2">Add New Sticker/Emoji</h5>
                            <div class="flex items-center space-x-2 mb-4">
                                <input type="text" id="new-sticker-url" placeholder="Paste URL or Emoji" class="flex-1 px-3 py-2 border border-theme bg-theme-secondary rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400">
                                <button id="add-sticker-btn" class="bg-blue-500 text-white py-2 px-4 rounded-lg hover:bg-blue-600">Add</button>
                            </div>
                            <h5 class="font-semibold mb-2">Current Stickers & Emojis</h5>
                            <div id="sticker-list-container" class="grid grid-cols-8 gap-2">
                            </div>
                         </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Call Modal -->
    <div id="call-modal" class="call-modal hidden">
        <div id="incoming-call-notification" class="call-incoming-notification hidden">
            <span id="caller-name"></span> is calling...
            <button id="answer-call-btn" class="bg-blue-500 text-white">Answer</button>
            <button id="reject-call-btn" class="reject bg-red-500 text-white">Reject</button>
        </div>
        <h2 id="call-status-text" class="call-status">Connecting...</h2>
        <div class="video-container">
            <video id="remote-video" autoplay playsinline></video>
            <video id="local-video" autoplay muted playsinline class="local-video"></video>
        </div>
        <div class="call-controls">
            <button id="toggle-audio-btn"><i class="fas fa-microphone"></i></button>
            <button id="toggle-video-btn"><i class="fas fa-video"></i></button>
            <button id="hangup-call-btn" class="hangup"><i class="fas fa-phone-slash"></i></button>
        </div>
    </div>


    <script type="module">

        // --- best-chat-part3.js à¤•à¤¾ à¤•à¥‹à¤¡ à¤¯à¤¹à¤¾à¤ à¤¸à¥‡ à¤¶à¥à¤°à¥‚ à¤¹à¥‹à¤¤à¤¾ à¤¹à¥ˆ ---

        // Firebase and Cloudinary Configurations
        const firebaseConfig = {
    apiKey: process.env.REACT_APP_FIREBASE_API_KEY,
    authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,
    databaseURL: process.env.REACT_APP_FIREBASE_DATABASE_URL,
    projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID,
    storageBucket: process.env.REACT_APP_FIREBASE_STORAGE_BUCKET,
    messagingSenderId: process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID,
    appId: process.env.REACT_APP_FIREBASE_APP_ID
};
const cloudinaryConfig = {
    cloud_name: process.env.REACT_APP_CLOUDINARY_CLOUD_NAME,
    upload_preset: process.env.REACT_APP_CLOUDINARY_UPLOAD_PRESET
};
const ADMIN_EMAIL = process.env.REACT_APP_ADMIN_EMAIL;
const GIPHY_API_KEY = process.env.REACT_APP_GIPHY_API_KEY;
          // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signOut, onAuthStateChanged, signInWithEmailAndPassword, createUserWithEmailAndPassword } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, collection, query, addDoc, serverTimestamp, orderBy, getDocs, writeBatch, updateDoc, deleteDoc, arrayUnion, arrayRemove } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
        import { getDatabase, ref, onValue, set, onDisconnect, remove, off, push } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const rtdb = getDatabase(app);

        // Global State
        let currentUser = null;
        let isAdmin = false;
        let currentChatUser = null;
        let currentChatId = null;
        let unsubscribeMessages = null;
        let typingTimeout = null;
        let typingListenerRef = null;
        // Call-related global state
        let peerConnection = null;
        let localStream = null;
        let remoteStream = null;
        let currentCallId = null;
        let callType = null; // 'audio' or 'video'
        let isCaller = false;
        let isMicMuted = false;
        let isVideoOff = false;

        // Function to update state variables
        function setChatState(key, value) {
            if (key === 'currentUser') currentUser = value;
            if (key === 'isAdmin') isAdmin = value;
            if (key === 'currentChatUser') currentChatUser = value;
            if (key === 'currentChatId') currentChatId = value;
            if (key === 'unsubscribeMessages') unsubscribeMessages = value;
            if (key === 'typingTimeout') typingTimeout = value;
            if (key === 'typingListenerRef') typingListenerRef = value;
            if (key === 'peerConnection') peerConnection = value;
            if (key === 'localStream') localStream = value;
            if (key === 'remoteStream') remoteStream = value;
            if (key === 'currentCallId') currentCallId = value;
            if (key === 'callType') callType = value;
            if (key === 'isCaller') isCaller = value;
            if (key === 'isMicMuted') isMicMuted = value;
            if (key === 'isVideoOff') isVideoOff = value;
        }

        // Presence and Status
        function setupPresence() {
            if (!currentUser) return;
            const userStatusDatabaseRef = ref(rtdb, '/status/' + currentUser.uid);
            const userStatusFirestoreRef = doc(db, 'users', currentUser.uid);
            const isOfflineForRTDB = { state: 'offline' };
            const isOnlineForRTDB = { state: 'online' };
            const isOfflineForFirestore = { isOnline: false, lastSeen: serverTimestamp() };
            const isOnlineForFirestore = { isOnline: true };
            const connectedRef = ref(rtdb, '.info/connected');
            onValue(connectedRef, (snap) => {
                if (snap.val() === true) {
                    set(userStatusDatabaseRef, isOnlineForRTDB);
                    updateDoc(userStatusFirestoreRef, isOnlineForFirestore);
                    onDisconnect(userStatusDatabaseRef).set(isOfflineForRTDB).then(() => {
                        updateDoc(userStatusFirestoreRef, isOfflineForFirestore);
                    });
                }
            });
        }

        let siteSettings = {};
        function listenToSiteSettings() {
            const settingsDocRef = doc(db, "siteSettings", "config");
            onSnapshot(settingsDocRef, (docSnap) => {
                siteSettings = docSnap.exists() ? docSnap.data() : { maintenanceMode: false, registrationsEnabled: true, stickers: [] };
                if (siteSettings.maintenanceMode && !isAdmin) {
                    document.getElementById('maintenance-screen').classList.remove('hidden');
                } else {
                    document.getElementById('maintenance-screen').classList.add('hidden');
                }
                if (isAdmin){
                    document.getElementById('maintenance-toggle').checked = siteSettings.maintenanceMode;
                    document.getElementById('registration-toggle').checked = siteSettings.registrationsEnabled;
                }
                const authToggleText = document.getElementById('auth-toggle-text');
                const authToggleLink = document.getElementById('auth-toggle-link');
                if (!siteSettings.registrationsEnabled) {
                    authToggleText.classList.add('hidden');
                    authToggleLink.classList.add('hidden');
                } else {
                    authToggleText.classList.remove('hidden');
                    authToggleLink.classList.remove('hidden');
                }
            });
        }

        async function loadUserList() {
            const userListEl = document.getElementById('user-list');
            const q = query(collection(db, "users"));
            onSnapshot(q, (snapshot) => {
                userListEl.innerHTML = '';
                snapshot.forEach(doc => {
                    const user = doc.data();
                    if (user.uid === currentUser.uid) return;
                    const userEl = document.createElement('div');
                    userEl.className = 'flex items-center p-3 hover:bg-theme-tertiary cursor-pointer';
                    userEl.dataset.uid = user.uid;
                    userEl.innerHTML = `
                        <div class="relative">
                            <img src="${user.photoURL}" class="w-12 h-12 rounded-full mr-4">
                            ${user.isOnline ? '<span class="absolute bottom-0 right-4 w-3 h-3 bg-green-500 border-2 border-white rounded-full"></span>' : ''}
                        </div>
                        <div>
                            <h4 class="font-semibold">${user.displayName}</h4>
                            <p class="text-sm text-theme-secondary">${user.isAdmin ? 'Admin' : 'User'}</p>
                        </div>
                    `;
                    userEl.addEventListener('click', () => startChat(user));
                    userListEl.appendChild(userEl);
                });
            });
        }

        async function startChat(otherUser) {
            setChatState('currentChatUser', otherUser);
            document.getElementById('welcome-screen').classList.add('hidden');
            document.getElementById('chat-window').classList.remove('hidden');

            if (window.innerWidth < 768) {
                document.getElementById('chat-list-container').classList.add('hidden');
                document.getElementById('chat-window-wrapper').classList.remove('hidden');
            }

            document.getElementById('chat-header-avatar').src = otherUser.photoURL;
            document.getElementById('chat-header-name').textContent = otherUser.displayName;

            const userStatusRef = ref(rtdb, '/status/' + otherUser.uid);
            onValue(userStatusRef, (snap) => {
    const statusEl = document.getElementById('chat-header-status');
    if (snap.exists() && snap.val().state === 'online') {
        statusEl.textContent = 'Online';
        statusEl.className = 'text-sm text-green-500';
        currentChatUser.isOnline = true;   // <-- FIX
    } else {
        statusEl.textContent = 'Offline';
        statusEl.className = 'text-sm text-gray-400';
        currentChatUser.isOnline = false;  // <-- FIX
    }
});

            const uids = [currentUser.uid, otherUser.uid].sort();
            setChatState('currentChatId', uids.join('_'));

            const messagesRef = collection(db, 'chats', currentChatId, 'messages');
            const q = query(messagesRef);
            const querySnapshot = await getDocs(q);
            const batch = writeBatch(db);
            querySnapshot.forEach(docSnap => {
                const msg = docSnap.data();
                if (msg.senderUid !== currentUser.uid && !msg.seenAt) {
                    batch.update(doc(messagesRef, docSnap.id), { seenAt: serverTimestamp() });
                }
            });
            await batch.commit();

            loadMessages();

            const typingIndicatorEl = document.getElementById('typing-indicator');
            if (typingListenerRef) {
                off(typingListenerRef);
            }
            setChatState('typingListenerRef', ref(rtdb, `typing/${currentChatId}/${currentChatUser.uid}`));
            onValue(typingListenerRef, (snapshot) => {
                if (snapshot.exists() && snapshot.val() === true) {
                    typingIndicatorEl.textContent = 'typing...';
                } else {
                    typingIndicatorEl.textContent = '';
                }
            });
            listenForCalls(); // Start listening for calls when a chat is opened
        }

        // Messages and media
        function loadMessages() {
            if (unsubscribeMessages) unsubscribeMessages();
            const messagesContainer = document.getElementById('messages-container');
            messagesContainer.innerHTML = '';
            const messagesRef = collection(db, 'chats', currentChatId, 'messages');
            const q = query(messagesRef, orderBy('timestamp'));

            setChatState('unsubscribeMessages', onSnapshot(q, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    const msg = change.doc.data();
                    if (change.type === "added") {
                        const tempMsg = messagesContainer.querySelector(`[data-temp-content="${msg.content}"]`);
                        if (tempMsg) {
                            tempMsg.dataset.id = change.doc.id;
                            tempMsg.dataset.tempContent = '';
                            updateMessageStatus(tempMsg, msg);
                        } else {
                            displayMessage(msg, change.doc.id);
                        }
                    }
                    if (change.type === "modified") {
                        const existingMsg = messagesContainer.querySelector(`[data-id="${change.doc.id}"]`);
                        if (existingMsg) {
                            updateMessageStatus(existingMsg, msg);
                        }
                    }
                });
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }));
        }

        async function displayMessage(msg, docId) {
            const messagesContainer = document.getElementById('messages-container');
            const isSent = msg.senderUid === currentUser.uid;
            const messageWrapper = document.createElement('div');
            messageWrapper.className = `flex mb-4 ${isSent ? 'justify-end' : 'justify-start'}`;
            messageWrapper.dataset.id = docId;
            if (!docId) messageWrapper.dataset.tempContent = msg.content;
            let contentHtml = '';

            if (msg.replyToId) {
                const originalMsgRef = doc(db, 'chats', currentChatId, 'messages', msg.replyToId);
                const originalMsgSnap = await getDoc(originalMsgRef);
                const originalMsgContent = originalMsgSnap.exists() ? (originalMsgSnap.data().content || "File/Media") : "Original message not found";
                const replyHtml = `<div class="p-2 border-l-4 border-blue-500 mb-2 bg-gray-100 dark:bg-gray-700 rounded">
                    <p class="text-xs text-blue-500">Replying to:</p>
                    <p class="text-sm truncate">${originalMsgContent}</p>
                </div>`;
                contentHtml += replyHtml;
            }

            switch(msg.type) {
                case 'text': contentHtml += `<p class="whitespace-pre-wrap break-words">${msg.content}</p>`; break;
                case 'image': contentHtml += `<img src="${msg.url}" class="rounded-lg shadow-md cursor-pointer" onclick="window.open('${msg.url}', '_blank')">`; break;
                case 'video': contentHtml += `<video controls src="${msg.url}" class="rounded-lg shadow-md"></video>`; break;
                case 'audio': contentHtml += `<audio controls src="${msg.url}"></audio>`; break;
                case 'sticker': contentHtml += `<img src="${msg.url}" class="w-24 h-24 object-contain">`; break;
            }

            const timestamp = msg.timestamp ? new Date(msg.timestamp.toDate()).toLocaleString() : 'Sending...';
            const statusIcon = getMessageStatusIcon(msg, isSent);

            messageWrapper.innerHTML = `
                <div class="max-w-xs lg:max-w-md">
                    <div class="${isSent ? 'message-bubble-sent' : 'message-bubble-received'} p-3 rounded-lg shadow-sm">
                        <div class="message-content">${contentHtml}</div>
                    </div>
                    <p class="text-xs text-theme-secondary mt-1 px-1 ${isSent ? 'text-right' : 'text-left'}">${timestamp} ${statusIcon}</p>
                </div>
            `;
            messagesContainer.appendChild(messageWrapper);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }


        function getMessageStatusIcon(msg, isSent) {
            if (!isSent) return '';
            if (msg.seenAt) {
                return `<i class="fas fa-check-double delivered-icon seen-icon ml-1"></i>`;
            } else if (msg.timestamp) {
                return `<i class="fas fa-check-double delivered-icon ml-1"></i>`;
            } else {
                return `<i class="fas fa-spinner fa-spin text-theme-secondary ml-1"></i>`;
            }
        }

        function updateMessageStatus(messageEl, msg) {
            const timestampEl = messageEl.querySelector('.text-xs');
            const newTimestamp = new Date(msg.timestamp.toDate()).toLocaleString();
            const newIcon = getMessageStatusIcon(msg, true);
            timestampEl.innerHTML = `${newTimestamp} ${newIcon}`;
        }

        async function sendMessage(type, content, url = null, replyToId = null) {
            if (!currentChatId || (!content && !url)) return;
            const messagesRef = collection(db, 'chats', currentChatId, 'messages');
            const tempMessage = {
                type, content, url, senderUid: currentUser.uid, timestamp: null, replyToId
            };
            displayMessage(tempMessage, null);
            await addDoc(messagesRef, { type, content, url, senderUid: currentUser.uid, timestamp: serverTimestamp(), replyToId });
        }

        // Upload file to Cloudinary
        async function uploadFile(file) {
            if (!file) return;
            document.getElementById('loading-spinner').classList.remove('hidden');
            const formData = new FormData();
            formData.append('file', file);
            formData.append('upload_preset', cloudinaryConfig.upload_preset);

            try {
                const response = await fetch(`https://api.cloudinary.com/v1_1/${cloudinaryConfig.cloud_name}/${file.type.startsWith('image/') ? 'image' : 'video'}/upload`, {
                    method: 'POST',
                    body: formData,
                });
                const data = await response.json();
                const type = file.type.startsWith('image/') ? 'image' : 'video';
                sendMessage(type, file.name, data.secure_url);
            } catch (error) {
                console.error("File upload failed:", error);
                alert("Failed to upload file.");
            } finally {
                document.getElementById('loading-spinner').classList.add('hidden');
            }
        }
        
        // Upload audio to Cloudinary
        async function uploadAudio(audioBlob) {
            if (!audioBlob) return;
            document.getElementById('loading-spinner').classList.remove('hidden');
            const formData = new FormData();
            formData.append('file', audioBlob);
            formData.append('upload_preset', cloudinaryConfig.upload_preset);

            try {
                const response = await fetch(`https://api.cloudinary.com/v1_1/${cloudinaryConfig.cloud_name}/raw/upload`, {
                    method: 'POST',
                    body: formData,
                });
                const data = await response.json();
                sendMessage('audio', 'Voice Message', data.secure_url);
            } catch (error) {
                console.error("Audio upload failed:", error);
                alert("Failed to upload voice message.");
            } finally {
                document.getElementById('loading-spinner').classList.add('hidden');
            }
        }


        // Update User Data
        async function updateUserData(uid, data) {
            const userDocRef = doc(db, "users", uid);
            return updateDoc(userDocRef, data);
        }

        // Emoji and sticker
        function initEmojiStickerPicker() {
            const picker = document.getElementById('emoji-sticker-picker');
            onSnapshot(doc(db, "siteSettings", "config"), (docSnap) => {
                const stickers = docSnap.exists() ? docSnap.data().stickers || [] : [];
                picker.innerHTML = '';
                const defaultEmojis = ['ðŸ˜€', 'ðŸ˜‚', 'â¤ï¸', 'ðŸ‘', 'ðŸ˜Š', 'ðŸ™', 'ðŸŽ‰', 'ðŸ˜¢', 'ðŸ”¥', 'ðŸ¤”', 'ðŸ˜Ž', 'ðŸ˜®', 'ðŸ˜‡', 'ðŸ¥³', 'ðŸ’¯', 'ðŸ™Œ'];
                defaultEmojis.forEach(emoji => {
                    const btn = document.createElement('button');
                    btn.className = 'p-1 rounded-full hover:bg-blue-200 text-2xl';
                    btn.textContent = emoji;
                    btn.addEventListener('click', () => {
                        document.getElementById('message-input').value += btn.textContent;
                        document.getElementById('message-input').focus();
                    });
                    picker.appendChild(btn);
                });
                stickers.forEach(sticker => {
                    const img = document.createElement('img');
                    img.src = sticker.url;
                    img.className = 'w-12 h-12 object-contain cursor-pointer';
                    img.addEventListener('click', () => {
                        sendMessage('sticker', 'sticker', sticker.url);
                        document.getElementById('emoji-sticker-picker').classList.add('hidden');
                    });
                    picker.appendChild(img);
                });
            });
        }
          // --- WebRTC Call Functionality ---
        const servers = {
            iceServers: [
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
            ],
            iceCandidatePoolSize: 10,
        };

        const callModal = document.getElementById('call-modal');
        const localVideo = document.getElementById('local-video');
        const remoteVideo = document.getElementById('remote-video');
        const callStatusText = document.getElementById('call-status-text');
        const toggleAudioBtn = document.getElementById('toggle-audio-btn');
        const toggleVideoBtn = document.getElementById('toggle-video-btn');
        const hangupCallBtn = document.getElementById('hangup-call-btn');
        const incomingCallNotification = document.getElementById('incoming-call-notification');
        const callerNameEl = document.getElementById('caller-name');
        const answerCallBtn = document.getElementById('answer-call-btn');
        const rejectCallBtn = document.getElementById('reject-call-btn');
        const voiceCallBtn = document.getElementById('voice-call-btn');
        const videoCallBtn = document.getElementById('video-call-btn');

        // Call button event listeners
        voiceCallBtn.addEventListener('click', () => startCall('audio'));
        videoCallBtn.addEventListener('click', () => startCall('video'));
        hangupCallBtn.addEventListener('click', hangupCall);
        toggleAudioBtn.addEventListener('click', toggleAudio);
        toggleVideoBtn.addEventListener('click', toggleVideo);
        answerCallBtn.addEventListener('click', answerCall);
        rejectCallBtn.addEventListener('click', rejectCall);

        async function startCall(type) {
            if (!currentChatUser || !currentUser) {
                alert("Please select a user to call.");
                return;
            }
            if (!currentChatUser.isOnline) {
                alert(`${currentChatUser.displayName} is offline and cannot be called.`);
                return;
            }

            setChatState('isCaller', true);
            setChatState('callType', type);
            callModal.classList.remove('hidden');
            callStatusText.textContent = `Calling ${currentChatUser.displayName}...`;
            loadingSpinner.classList.remove('hidden');

            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: (type === 'video'),
                    audio: true
                });
                localVideo.srcObject = localStream;
                setChatState('localStream', localStream);
                
                peerConnection = new RTCPeerConnection(servers);
                setChatState('peerConnection', peerConnection);

                localStream.getTracks().forEach((track) => {
                    peerConnection.addTrack(track, localStream);
                });

                peerConnection.ontrack = (event) => {
                    remoteStream = event.streams[0];
                    remoteVideo.srcObject = remoteStream;
                    setChatState('remoteStream', remoteStream);
                    callStatusText.textContent = `Connected with ${currentChatUser.displayName}`;
                };

                const callDocRef = await addDoc(collection(db, 'calls'), {
                    callerId: currentUser.uid,
                    callerName: currentUser.displayName,
                    receiverId: currentChatUser.uid,
                    callType: type,
                    status: 'ringing', // ringing, accepted, rejected, ended
                    createdAt: serverTimestamp(),
                });
                setChatState('currentCallId', callDocRef.id);
                console.log("Call document created:", currentCallId);

                // For signaling - ICE candidates
                const callerCandidatesCollection = collection(callDocRef, 'callerCandidates');
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        addDoc(callerCandidatesCollection, event.candidate.toJSON());
                    }
                };

                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                await updateDoc(callDocRef, { offer: { type: offer.type, sdp: offer.sdp } });

                // Listen for receiver's answer
                onSnapshot(callDocRef, async (snapshot) => {
                    const data = snapshot.data();
                    if (data?.answer && !peerConnection.currentRemoteDescription) {
                        const answerDescription = new RTCSessionDescription(data.answer);
                        await peerConnection.setRemoteDescription(answerDescription);
                        callStatusText.textContent = `Connected with ${currentChatUser.displayName}`;
                        loadingSpinner.classList.add('hidden');
                    }
                    if (data?.status === 'rejected') {
                        callStatusText.textContent = `${currentChatUser.displayName} rejected your call.`;
                        setTimeout(hangupCall, 2000);
                    }
                    if (data?.status === 'ended' && peerConnection) {
                         // Call ended by other party
                         callStatusText.textContent = `Call ended by ${currentChatUser.displayName}`;
                         setTimeout(hangupCall, 2000);
                    }
                });

                // Listen for receiver's ICE candidates
                onSnapshot(collection(callDocRef, 'receiverCandidates'), (snapshot) => {
                    snapshot.docChanges().forEach(async (change) => {
                        if (change.type === 'added') {
                            const candidate = new RTCIceCandidate(change.doc.data());
                            await peerConnection.addIceCandidate(candidate);
                        }
                    });
                });

            } catch (error) {
                console.error("Error starting call:", error);
                alert("Could not start call. Please check your microphone/camera permissions and internet connection.");
                hangupCall();
            } finally {
                loadingSpinner.classList.add('hidden');
            }
        }

        async function answerCall() {
            incomingCallNotification.classList.add('hidden');
            callModal.classList.remove('hidden');
            loadingSpinner.classList.remove('hidden');
            setChatState('isCaller', false);
            callStatusText.textContent = `Connecting to ${currentChatUser.displayName}...`; // currentChatUser is the caller here

            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: (callType === 'video'),
                    audio: true
                });
                localVideo.srcObject = localStream;
                setChatState('localStream', localStream);

                peerConnection = new RTCPeerConnection(servers);
                setChatState('peerConnection', peerConnection);

                localStream.getTracks().forEach((track) => {
                    peerConnection.addTrack(track, localStream);
                });

                peerConnection.ontrack = (event) => {
                    remoteStream = event.streams[0];
                    remoteVideo.srcObject = remoteStream;
                    setChatState('remoteStream', remoteStream);
                    callStatusText.textContent = `Connected with ${currentChatUser.displayName}`;
                };

                const callDocRef = doc(db, 'calls', currentCallId);

                // For signaling - ICE candidates
                const receiverCandidatesCollection = collection(callDocRef, 'receiverCandidates');
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        addDoc(receiverCandidatesCollection, event.candidate.toJSON());
                    }
                };

                const callData = (await getDoc(callDocRef)).data();
                const offerDescription = new RTCSessionDescription(callData.offer);
                await peerConnection.setRemoteDescription(offerDescription);

                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                await updateDoc(callDocRef, { answer: { type: answer.type, sdp: answer.sdp }, status: 'accepted' });

                // Listen for caller's ICE candidates
                onSnapshot(collection(callDocRef, 'callerCandidates'), (snapshot) => {
                    snapshot.docChanges().forEach(async (change) => {
                        if (change.type === 'added') {
                            const candidate = new RTCIceCandidate(change.doc.data());
                            await peerConnection.addIceCandidate(candidate);
                        }
                    });
                });

            } catch (error) {
                console.error("Error answering call:", error);
                alert("Could not answer call. Please check your microphone/camera permissions.");
                rejectCall();
            } finally {
                loadingSpinner.classList.add('hidden');
            }
        }

        async function rejectCall() {
            incomingCallNotification.classList.add('hidden');
            callModal.classList.add('hidden');
            if (currentCallId) {
                try {
                    await updateDoc(doc(db, 'calls', currentCallId), { status: 'rejected' });
                } catch (error) {
                    console.error("Error rejecting call:", error);
                }
            }
            resetCallState();
        }

        async function hangupCall() {
            if (peerConnection) {
                peerConnection.close();
                setChatState('peerConnection', null);
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localVideo.srcObject = null;
                setChatState('localStream', null);
            }
            if (remoteStream) {
                remoteVideo.srcObject = null;
                setChatState('remoteStream', null);
            }

            if (currentCallId) {
                try {
                    const callDocRef = doc(db, 'calls', currentCallId);
                    const callDocSnap = await getDoc(callDocRef);
                    if(callDocSnap.exists() && callDocSnap.data().status !== 'ended') {
                        await updateDoc(callDocRef, { status: 'ended' });
                    }
                    // Optionally delete call document and candidates after some time
                    // setTimeout(async () => {
                    //     const batch = writeBatch(db);
                    //     const callerCandidates = await getDocs(collection(callDocRef, 'callerCandidates'));
                    //     callerCandidates.forEach(doc => batch.delete(doc.ref));
                    //     const receiverCandidates = await getDocs(collection(callDocRef, 'receiverCandidates'));
                    //     receiverCandidates.forEach(doc => batch.delete(doc.ref));
                    //     batch.delete(callDocRef);
                    //     await batch.commit();
                    //     console.log("Call data cleaned up.");
                    // }, 5000); // Delete after 5 seconds
                } catch (error) {
                    console.error("Error updating call status to ended:", error);
                }
            }

            resetCallState();
        }

        function resetCallState() {
            setChatState('peerConnection', null);
            setChatState('localStream', null);
            setChatState('remoteStream', null);
            setChatState('currentCallId', null);
            setChatState('callType', null);
            setChatState('isCaller', false);
            setChatState('isMicMuted', false);
            setChatState('isVideoOff', false);

            callModal.classList.add('hidden');
            incomingCallNotification.classList.add('hidden');
            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
            callStatusText.textContent = '';
            toggleAudioBtn.innerHTML = '<i class="fas fa-microphone"></i>';
            toggleVideoBtn.innerHTML = '<i class="fas fa-video"></i>';
        }

        function toggleAudio() {
            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = !track.enabled;
                    isMicMuted = !track.enabled;
                    toggleAudioBtn.innerHTML = isMicMuted ? '<i class="fas fa-microphone-slash"></i>' : '<i class="fas fa-microphone"></i>';
                });
            }
        }

        function toggleVideo() {
            if (localStream) {
                localStream.getVideoTracks().forEach(track => {
                    track.enabled = !track.enabled;
                    isVideoOff = !track.enabled;
                    toggleVideoBtn.innerHTML = isVideoOff ? '<i class="fas fa-video-slash"></i>' : '<i class="fas fa-video"></i>';
                });
            }
        }

        // Listen for incoming calls
        function listenForCalls() {
            if (!currentUser) return;
            const callsRef = collection(db, 'calls');
            const q = query(callsRef, where("receiverId", "==", currentUser.uid), where("status", "==", "ringing"));

            onSnapshot(q, (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === 'added') {
                        const callData = change.doc.data();
                        console.log("Incoming call data:", callData);
                        if (!callModal.classList.contains('hidden')) {
                            console.log("Already in a call or call modal active, ignoring new incoming call.");
                            return; // Don't show new incoming call if already in one
                        }

                        setChatState('currentCallId', change.doc.id);
                        setChatState('callType', callData.callType);
                        
                        // Set currentChatUser to the caller for consistency
                        const callerDoc = await getDoc(doc(db, 'users', callData.callerId));
                        if(callerDoc.exists()){
                            setChatState('currentChatUser', callerDoc.data());
                            callerNameEl.textContent = callerDoc.data().displayName;
                        } else {
                            callerNameEl.textContent = "Unknown Caller";
                        }
                        
                        incomingCallNotification.classList.remove('hidden');
                    }
                    if (change.type === 'modified') {
                        const callData = change.doc.data();
                        if (change.doc.id === currentCallId) {
                            if (callData.status === 'ended' || callData.status === 'rejected') {
                                if (isCaller) { // If I am the caller
                                    callStatusText.textContent = `${currentChatUser.displayName} ${callData.status === 'ended' ? 'ended' : 'rejected'} the call.`;
                                } else { // If I am the receiver and call was ended by caller
                                    callStatusText.textContent = `Call ${callData.status}.`;
                                }
                                setTimeout(hangupCall, 2000);
                            }
                        }
                    }
                    if (change.type === 'removed' && change.doc.id === currentCallId) {
                        // Call document was removed, implying call ended or rejected by other party
                        if(!callModal.classList.contains('hidden')) { // Only show message if modal is open
                            callStatusText.textContent = "Call ended by other party.";
                            setTimeout(hangupCall, 2000);
                        } else {
                             resetCallState(); // If modal is not open, just reset
                        }
                    }
                });
            });
        }
            // --- best-chat-part3.js à¤•à¤¾ à¤•à¥‹à¤¡ à¤¯à¤¹à¤¾à¤ à¤¸à¤®à¤¾à¤ªà¥à¤¤ à¤¹à¥‹à¤¤à¤¾ à¤¹à¥ˆ ---
        
        // --- best-chat-part2.js à¤•à¤¾ à¤•à¥‹à¤¡ à¤¯à¤¹à¤¾à¤ à¤¸à¥‡ à¤¶à¥à¤°à¥‚ à¤¹à¥‹à¤¤à¤¾ à¤¹à¥ˆ ---

        // Global UI elements
        const loadingSpinner = document.getElementById('loading-spinner');
        const authScreen = document.getElementById('auth-screen');
        const mainApp = document.getElementById('main-app');
        const maintenanceScreen = document.getElementById('maintenance-screen');
        const chatListContainer = document.getElementById('chat-list-container');
        const chatWindowWrapper = document.getElementById('chat-window-wrapper');
        const backToChatsBtn = document.getElementById('back-to-chats-btn');
        const welcomeScreen = document.getElementById('welcome-screen');
        const themeToggleButton = document.getElementById('theme-toggle-button');
        const authForm = document.getElementById('auth-form');
        const authToggleLink = document.getElementById('auth-toggle-link');
        const authError = document.getElementById('auth-error');
        const authToggleText = document.getElementById('auth-toggle-text');
        const adminPanelButton = document.getElementById('admin-panel-button');
        const adminPanel = document.getElementById('admin-panel');
        const closeAdminPanel = document.getElementById('close-admin-panel');

        // New UI elements for new features
        const editProfileModal = document.getElementById('edit-profile-modal');
        const editProfileButton = document.getElementById('edit-profile-button');
        const closeEditProfileModal = document.getElementById('close-edit-profile-modal');
        const profileAvatarPreview = document.getElementById('profile-avatar-preview');
        const changeAvatarBtn = document.getElementById('change-avatar-btn');
        const avatarInput = document.getElementById('avatar-input');
        const displayNameInput = document.getElementById('display-name-input');
        const saveProfileBtn = document.getElementById('save-profile-btn');
        const messageInput = document.getElementById('message-input');
        const sendBtn = document.getElementById('send-btn');
        const replyBar = document.getElementById('reply-bar');
        const replyText = document.getElementById('reply-text');
        const cancelReplyBtn = document.getElementById('cancel-reply-btn');
        const chatHeaderAvatar = document.getElementById('chat-header-avatar');
        const deleteChatBtn = document.getElementById('delete-chat-btn');
        const fullscreenImageModal = document.getElementById('fullscreen-image-modal');
        const fullscreenImage = document.getElementById('fullscreen-image');
        const recordVoiceBtn = document.getElementById('record-voice-btn');
        const recordingStatus = document.getElementById('recording-status');


        let isLogin = true;
        let replyToMessageId = null;
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;

        // --- Helper Functions ---
        function showAuthScreen() {
            authScreen.classList.remove('hidden');
            mainApp.classList.add('hidden');
            loadingSpinner.classList.add('hidden');
            maintenanceScreen.classList.add('hidden');
        }

        function showMainApp() {
            authScreen.classList.add('hidden');
            mainApp.classList.remove('hidden');
            mainApp.classList.add('flex');
            loadingSpinner.classList.add('hidden');
            maintenanceScreen.classList.add('hidden');
            chatListContainer.classList.remove('hidden');
            chatWindowWrapper.classList.add('hidden');
        }

        function showMaintenanceScreen() {
            authScreen.classList.add('hidden');
            mainApp.classList.add('hidden');
            loadingSpinner.classList.add('hidden');
            maintenanceScreen.classList.remove('hidden');
        }
        
        // --- NEW ADMIN PANEL LOGIC ---

        async function loadAdminUsers() {
            const userListEl = document.getElementById('admin-user-list');
            userListEl.innerHTML = '<p class="text-theme-secondary">Loading users...</p>';
            const usersRef = collection(db, "users");
            const q = query(usersRef, orderBy("displayName"));
            const querySnapshot = await getDocs(q);
            userListEl.innerHTML = '';
            querySnapshot.forEach(doc => {
                const user = doc.data();
                const userEl = document.createElement('div');
                userEl.className = 'p-3 border border-theme rounded-lg flex items-center justify-between hover:bg-theme-tertiary transition-colors';
                userEl.innerHTML = `
                    <div class="flex items-center">
                        <img src="${user.photoURL}" class="w-10 h-10 rounded-full mr-3">
                        <div>
                            <p class="font-semibold text-theme-primary">${user.displayName}</p>
                            <p class="text-sm text-theme-secondary">${user.email}</p>
                        </div>
                    </div>
                    <div class="flex items-center space-x-2">
                        <span class="text-xs font-bold text-theme-primary px-2 py-1 rounded-full ${user.isAdmin ? 'bg-red-500 text-white' : 'bg-green-500 text-white'}">${user.isAdmin ? 'Admin' : 'User'}</span>
                    </div>
                `;
                userListEl.appendChild(userEl);
            });
        }

        function loadAdminStickers() {
            const stickerListEl = document.getElementById('sticker-list-container');
            onSnapshot(doc(db, "siteSettings", "config"), (docSnap) => {
                const stickers = docSnap.exists() ? docSnap.data().stickers || [] : [];
                stickerListEl.innerHTML = '';
                if (stickers.length === 0) {
                    stickerListEl.innerHTML = '<p class="text-theme-secondary">No stickers added yet.</p>';
                    return;
                }
                stickers.forEach(sticker => {
                    const stickerWrapper = document.createElement('div');
                    stickerWrapper.className = 'relative group';
                    stickerWrapper.innerHTML = `
                        <img src="${sticker.url}" class="w-16 h-16 object-contain">
                        <button class="remove-sticker-btn absolute top-0 right-0 p-1 bg-red-500 text-white rounded-full opacity-0 group-hover:opacity-100 transition-opacity">
                            <i class="fas fa-times text-xs"></i>
                        </button>
                    `;
                    stickerWrapper.querySelector('.remove-sticker-btn').addEventListener('click', () => removeSticker(sticker));
                    stickerListEl.appendChild(stickerWrapper);
                });
            });
        }

        async function addSticker() {
            const input = document.getElementById('new-sticker-url');
            const url = input.value.trim();
            if (!url) return;

            const settingsDocRef = doc(db, "siteSettings", "config");
            const newSticker = { url: url, addedAt: serverTimestamp() };
            try {
                await updateDoc(settingsDocRef, { stickers: arrayUnion(newSticker) });
                input.value = '';
                alert("Sticker added successfully!");
            } catch (error) {
                console.error("Error adding sticker:", error);
                alert("Failed to add sticker.");
            }
        }

        async function removeSticker(sticker) {
            const settingsDocRef = doc(db, "siteSettings", "config");
            try {
                await updateDoc(settingsDocRef, { stickers: arrayRemove(sticker) });
                alert("Sticker removed successfully!");
            } catch (error) {
                console.error("Error removing sticker:", error);
                alert("Failed to remove sticker.");
            }
        }

        // --- END NEW ADMIN PANEL LOGIC ---


        // --- NEW FEATURE LOGIC ---

        // Profile Customization
        const editProfileModalLogic = () => {
            editProfileButton.addEventListener('click', async (e) => {
                e.preventDefault();
                document.getElementById('user-menu').classList.add('hidden');
                editProfileModal.classList.remove('hidden');
                const userDocRef = doc(db, "users", currentUser.uid);
                const userDocSnap = await getDoc(userDocRef);
                if (userDocSnap.exists()) {
                    const userData = userDocSnap.data();
                    profileAvatarPreview.src = userData.photoURL || `https://ui-avatars.com/api/?name=${userData.displayName}`;
                    displayNameInput.value = userData.displayName || '';
                }
            });

            closeEditProfileModal.addEventListener('click', () => {
                editProfileModal.classList.add('hidden');
            });

            changeAvatarBtn.addEventListener('click', () => {
                avatarInput.click();
            });

            avatarInput.addEventListener('change', (e) => {
                if (e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        profileAvatarPreview.src = e.target.result;
                    };
                    reader.readAsDataURL(e.target.files[0]);
                }
            });

            saveProfileBtn.addEventListener('click', async () => {
                loadingSpinner.classList.remove('hidden');
                const newDisplayName = displayNameInput.value.trim();
                let newPhotoURL = profileAvatarPreview.src;

                if (avatarInput.files[0]) {
                    // Upload new image to Cloudinary
                    const formData = new FormData();
                    formData.append('file', avatarInput.files[0]);
                    formData.append('upload_preset', cloudinaryConfig.upload_preset);

                    try {
                        const response = await fetch(`https://api.cloudinary.com/v1_1/${cloudinaryConfig.cloud_name}/image/upload`, {
                            method: 'POST',
                            body: formData,
                        });
                        const data = await response.json();
                        newPhotoURL = data.secure_url;
                    } catch (error) {
                        console.error("Error uploading profile picture:", error);
                        alert("Failed to update profile picture. Please try again.");
                        loadingSpinner.classList.add('hidden');
                        return;
                    }
                }

                // Update user data in Firestore
                try {
                    await updateUserData(currentUser.uid, {
                        displayName: newDisplayName,
                        photoURL: newPhotoURL
                    });
                    alert("Profile updated successfully!");
                } catch (error) {
                    console.error("Error updating user data:", error);
                    alert("Failed to update profile. Please try again.");
                } finally {
                    loadingSpinner.classList.add('hidden');
                    editProfileModal.classList.add('hidden');
                }
            });
        };

        // Message Reply
        const messageReplyLogic = () => {
            const messagesContainer = document.getElementById('messages-container');

            // Listen for clicks on messages to enable reply mode
            messagesContainer.addEventListener('click', (e) => {
                const messageWrapper = e.target.closest('.message-bubble-sent, .message-bubble-received');
                if (messageWrapper) {
                    const messageEl = messageWrapper.closest('[data-id]');
                    if (messageEl) {
                        replyToMessageId = messageEl.dataset.id;
                        const messageContentEl = messageWrapper.querySelector('.message-content');
                        replyText.textContent = messageContentEl.textContent || 'File/Media';
                        replyBar.classList.remove('hidden');
                        messageInput.focus();
                    }
                }
            });

            cancelReplyBtn.addEventListener('click', () => {
                replyToMessageId = null;
                replyBar.classList.add('hidden');
            });

            sendBtn.addEventListener('click', () => {
                const input = document.getElementById('message-input');
                if (input.value.trim()) {
                    sendMessage('text', input.value.trim(), null, replyToMessageId);
                    input.value = '';
                    replyToMessageId = null;
                    replyBar.classList.add('hidden');
                }
            });
        };

        // Theme Toggle
        const themeToggleLogic = () => {
            const htmlEl = document.documentElement;
            const themeToggleBtn = document.getElementById('theme-toggle-button');
            const iconEl = themeToggleBtn.querySelector('i');
            const textEl = themeToggleBtn.querySelector('span');

            const setTheme = (theme) => {
                if (theme === 'dark') {
                    htmlEl.classList.add('dark');
                    iconEl.className = 'fas fa-moon mr-2';
                    textEl.textContent = 'Switch to Light Mode';
                    localStorage.setItem('theme', 'dark');
                } else {
                    htmlEl.classList.remove('dark');
                    iconEl.className = 'fas fa-sun mr-2';
                    textEl.textContent = 'Switch to Dark Mode';
                    localStorage.setItem('theme', 'light');
                }
            };

            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                setTheme(savedTheme);
            } else {
                setTheme('light');
            }

            themeToggleBtn.addEventListener('click', (e) => {
                e.preventDefault();
                const currentTheme = htmlEl.classList.contains('dark') ? 'light' : 'dark';
                setTheme(currentTheme);
            });
        };

        // Fullscreen Image Logic
        const fullscreenImageLogic = () => {
            chatHeaderAvatar.addEventListener('click', () => {
                fullscreenImage.src = chatHeaderAvatar.src;
                fullscreenImageModal.classList.remove('hidden');
            });
        }

        // Admin Panel Logic
        const adminPanelLogic = () => {
            adminPanelButton.addEventListener('click', (e) => {
                e.preventDefault();
                document.getElementById('user-menu').classList.add('hidden');
                adminPanel.classList.remove('hidden');
                // Ensure correct initial tab is displayed
                document.getElementById('admin-tab-settings').classList.remove('hidden');
                document.getElementById('admin-tab-users').classList.add('hidden');
                document.getElementById('admin-tab-content').classList.add('hidden');
            });

            closeAdminPanel.addEventListener('click', () => {
                adminPanel.classList.add('hidden');
            });

            const tabLinks = document.querySelectorAll('.admin-tab-link');
            const tabContents = document.querySelectorAll('.admin-tab-content');

            tabLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    tabLinks.forEach(l => {
                        l.classList.remove('bg-theme-tertiary', 'text-theme-primary', 'font-semibold');
                        l.classList.add('text-theme-secondary', 'hover:bg-theme-tertiary', 'hover:text-theme-primary');
                    });
                    e.currentTarget.classList.add('bg-theme-tertiary', 'text-theme-primary', 'font-semibold');
                    e.currentTarget.classList.remove('text-theme-secondary', 'hover:bg-theme-tertiary', 'hover:text-theme-primary');

                    tabContents.forEach(content => content.classList.add('hidden'));

                    const targetTabId = e.currentTarget.getAttribute('href').substring(1);
                    document.getElementById(`admin-tab-${targetTabId}`).classList.remove('hidden');
                    
                    // --- NEW LOGIC: Call specific functions based on tab clicked ---
                    if (targetTabId === 'users') {
                        loadAdminUsers();
                    } else if (targetTabId === 'content') {
                        loadAdminStickers();
                    }
                    // --- END NEW LOGIC ---
                });
            });

            document.getElementById('add-sticker-btn').addEventListener('click', addSticker);
        };
        
        // Voice Recording Logic
        const voiceRecordingLogic = () => {
            recordVoiceBtn.addEventListener('click', async () => {
                if (isRecording) {
                    // Stop recording
                    mediaRecorder.stop();
                    recordVoiceBtn.innerHTML = `<i class="fas fa-microphone w-4 mr-3"></i>Record Voice`;
                    recordingStatus.classList.add('hidden');
                    isRecording = false;
                } else {
                    // Start recording
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        mediaRecorder = new MediaRecorder(stream);
                        audioChunks = [];
                        
                        mediaRecorder.ondataavailable = event => {
                            audioChunks.push(event.data);
                        };
                        
                        mediaRecorder.onstop = () => {
                            const audioBlob = new Blob(audioChunks, { 'type' : 'audio/webm; codecs=opus' });
                            uploadAudio(audioBlob);
                            stream.getTracks().forEach(track => track.stop());
                        };
                        
                        mediaRecorder.start();
                        recordVoiceBtn.innerHTML = `<i class="fas fa-stop-circle w-4 mr-3"></i>Stop Recording`;
                        recordingStatus.classList.remove('hidden');
                        isRecording = true;

                    } catch (err) {
                        console.error("Microphone access denied or failed:", err);
                        alert("Could not access microphone. Please allow microphone permissions.");
                    }
                }
            });
        };

        // --- Initial Setup and Event Listeners ---
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                setChatState('currentUser', user);
                const userDocRef = doc(db, "users", user.uid);
                const userDocSnap = await getDoc(userDocRef);

                if (userDocSnap.exists()) {
                    setChatState('isAdmin', userDocSnap.data().isAdmin || false);
                } else {
                    const newUserIsAdmin = user.email === ADMIN_EMAIL;
                    await setDoc(userDocRef, {
                        uid: user.uid,
                        email: user.email,
                        displayName: user.email.split('@')[0],
                        photoURL: `https://ui-avatars.com/api/?name=${user.email.split('@')[0]}&background=random`,
                        isAdmin: newUserIsAdmin
                    });
                    setChatState('isAdmin', newUserIsAdmin);
                }

                setupPresence();
                listenToSiteSettings();
                loadUI();
                editProfileModalLogic();
                messageReplyLogic();
                themeToggleLogic();
                fullscreenImageLogic();
                adminPanelLogic();
                voiceRecordingLogic();
            } else {
                setChatState('currentUser', null);
                setChatState('isAdmin', false);
                showAuthScreen();
            }
        });

        function loadUI() {
            if (!currentUser) return;
            const userDocRef = doc(db, "users", currentUser.uid);
            onSnapshot(userDocRef, (doc) => {
                 if(doc.exists()) {
                    const userData = doc.data();
                    document.getElementById('user-avatar').src = userData.photoURL || `https://ui-avatars.com/api/?name=${userData.email.split('@')[0]}`;
                 }
            });
            if(isAdmin) { document.getElementById('admin-panel-button').classList.remove('hidden'); }
            loadUserList();
            showMainApp();
            initEmojiStickerPicker();
            chatListContainer.classList.remove('hidden');
        }


        // Auth event listeners
        authToggleLink.addEventListener('click', (e) => {
            e.preventDefault();
            isLogin = !isLogin;
            document.getElementById('auth-title').textContent = isLogin ? 'Login' : 'Sign Up';
            document.getElementById('auth-button').textContent = isLogin ? 'Login' : 'Sign Up';
            authToggleText.textContent = isLogin ? "Don't have an account?" : "Already have an account?";
            authToggleLink.textContent = isLogin ? 'Sign Up' : 'Login';
            authError.classList.add('hidden');
        });

        authForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            loadingSpinner.classList.remove('hidden');
            authError.classList.add('hidden');
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            try {
                if(isLogin) {
                    await signInWithEmailAndPassword(auth, email, password);
                } else {
                    const settingsDocSnap = await getDoc(doc(db, "siteSettings", "config"));
                    const registrationsEnabled = settingsDocSnap.exists() ? settingsDocSnap.data().registrationsEnabled : true;
                    if (!registrationsEnabled) {
                        authError.textContent = "Sorry, new registrations are disabled by the admin.";
                        authError.classList.remove('hidden');
                        return;
                    }
                    await createUserWithEmailAndPassword(auth, email, password);
                }
            } catch (error) {
                console.error("Firebase Auth Error:", error.code, error.message);
                let errorMessage = "Authentication Error: Please try again.";
                if (error.code === 'auth/invalid-credential' || error.code === 'auth/wrong-password' || error.code === 'auth/user-not-found' || error.code === 'auth/invalid-email') {
                    errorMessage = "Authentication Error: Invalid email or password.";
                } else if (error.code === 'auth/email-already-in-use') {
                    errorMessage = "Authentication Error: This email is already registered.";
                }
                authError.textContent = errorMessage;
                authError.classList.remove('hidden');
            } finally {
                loadingSpinner.classList.add('hidden');
            }
        });

        // Other event listeners (unmodified from original)
        document.getElementById('logout-button').addEventListener('click', () => signOut(auth));
        document.getElementById('user-avatar').addEventListener('click', () => {
            document.getElementById('user-menu').classList.toggle('hidden');
        });
        document.getElementById('message-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendBtn.click();
            }
        });
        document.getElementById('attach-file-btn').addEventListener('click', () => document.getElementById('file-input').click());
        document.getElementById('file-input').addEventListener('change', (e) => {
            if (e.target.files[0]) uploadFile(e.target.files[0]);
        });
        document.getElementById('delete-chat-btn').addEventListener('click', async () => {
            if (!currentChatId || !currentChatUser) return;
            const confirmation = confirm(`Are you sure you want to delete all messages with ${currentChatUser.displayName}? This action cannot be undone.`);
            if (confirmation) {
                loadingSpinner.classList.remove('hidden');
                try {
                    const messagesRef = collection(db, 'chats', currentChatId, 'messages');
                    const querySnapshot = await getDocs(messagesRef);
                    const batch = writeBatch(db);
                    querySnapshot.forEach(doc => {
                        batch.delete(doc.ref);
                    });
                    await batch.commit();
                    document.getElementById('messages-container').innerHTML = '';
                    alert('Chat history deleted successfully.');
                } catch (error) {
                    console.error("Error deleting chat:", error);
                    alert("Failed to delete chat history.");
                } finally {
                    loadingSpinner.classList.add('hidden');
                }
            }
        });
        document.getElementById('emoji-sticker-btn').addEventListener('click', () => {
            document.getElementById('emoji-sticker-picker').classList.toggle('hidden');
        });
        document.getElementById('more-options-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('more-options-menu').classList.toggle('hidden');
        });
        document.addEventListener('click', (e) => {
            const moreOptionsMenu = document.getElementById('more-options-menu');
            if (!moreOptionsMenu.classList.contains('hidden') && !moreOptionsMenu.contains(e.target) && !document.getElementById('more-options-btn').contains(e.target)) {
                moreOptionsMenu.classList.add('hidden');
            }
        });
        document.getElementById('chat-with-admin-btn').addEventListener('click', async () => {
            const q = query(collection(db, "users"));
            const snapshot = await getDocs(q);
            let adminUser = null;
            snapshot.forEach(doc => {
                const user = doc.data();
                if(user.isAdmin && user.uid !== currentUser.uid) {
                    adminUser = user;
                }
            });
            if (adminUser) {
                startChat(adminUser);
            } else {
                alert("No available admins to chat with at the moment.");
            }
        });
        backToChatsBtn.addEventListener('click', () => {
            chatListContainer.classList.remove('hidden');
            chatWindowWrapper.classList.add('hidden');
            document.getElementById('chat-window').classList.add('hidden');
            welcomeScreen.classList.remove('hidden');
        });

        // --- best-chat-part2.js à¤•à¤¾ à¤•à¥‹à¤¡ à¤¯à¤¹à¤¾à¤ à¤¸à¤®à¤¾à¤ªà¥à¤¤ à¤¹à¥‹à¤¤à¤¾ à¤¹à¥ˆ ---
    </script>
</body>
</html>
